
```Take a first pass at decomposing @day_1_problem.txt into a set of requirements to build a program in python that solves the problem. Insert that into @instructions.md 
```

```
Using @instructions.md but ignoring the //Prompt comment. 

- Use Poetry for managing dependencies 
- Don't rely on modern libraries like pandas. Do it with built in data structures
- Have each line of code be robustly commented
- Show your reasoning in the comments as well as have a step by step guide for all of the code at the top
- When the program runs, have it show its work

Build a python script to achieve the spec. The file to process is @input_data.txt 
```

```
We now have a new riff on  @day_1_problem_part_2.txt. Create a set of requirements in a new spec called 'instructions2.md' to achieve this
```

```
- Use Poetry for managing dependencies 
- Don't rely on modern libraries like pandas. Do it with built in data structures
- Have each line of code be robustly commented
- Show your reasoning in the comments as well as have a step by step guide for all of the code at the top
- When the program runs, have it show its work

Build a python script called solution2.py to achieve the spec in@instructions2.md . The file to process is @input_data.txt
```

```
I've now updated my directory structure to have an input, prompts, solution and spec folder.

Update @solution.py and @solution2.py to find the right location of the @input_data.txt file used in each of them

Also, in addition to writing the output to terminal when each are run, run the output to the solution folder in an appropirately named text file.
```

